User:

- id is uuid

- name is text

- friends is many User through .befriendedBy

- befriendedBy is many User through .friends

- popularity is number through count(.friends)

- authoredTasks is many Task through .author

- assignedTasks is many Task through .assignees

- countTasksCompleted is number through count(.assignedTasks.completionStatus == done)

Task:

- id is uuid

- title is text

- content is text

- attachments is many file -- blob

- completionStatus is eigenstate through either(done, not_done)

- author is User through .authoredTasks

- assignees is many User through .assignedTasks

- summary is text through summarize(.content, length:short) -- we'll need to prioritize eigenvalues by nearest scope so as to not limit other eigenvalues (i.e. `short` should also be able to be defined in this schema)

- addFile is action through put(.attachments)

- removeFile is action through drop(.attachments, :key) -- named slot `key` requires that it be supplied before executing `removeFile`

- markComplete is action through set(.completionStatus, value:done)

- parentTasks is many Task and super

- subtasks is many Task and sub

- subtask is action through put(.subtasks)

- relatedTasks is many Task and related -- let's enforce that supers and subs and related are mutually exclusive to avoid headaches

- priority is eigenstate through either(high, medium, low) -- variable argument length

- dueDate is date

- timeRemaining is seconds through ticktock(.dueDate) -- possible positive if ticktock has surpassed the due date, negative if before (similar to T-minus measuring)

- startTime is timestamp

- endTime is timestamp

- timeSpent is seconds through sum(.subtasks.timeSpent, ticktock(.startTime, .endTime)) -- formally, this will go down one level and aggregate.
                                                                                        -- implicitly, this will recurse the dependency graph all the way to the bottom...
